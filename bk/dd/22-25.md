# 二十二至二十五章
## 22.1 为何JS使用函数指针非常简单？
因为在js中，所有的函数都是对象

## 22.2 在安全类型检测中，为何使用toString()能保证返回一致的值？
因为原生数组或函数的构造函数名与全局作用域无关

## 22.3 为何在web开发中区分原生与非原生对象非常重要？
确切知道某个对象有哪些功能

## 22.4 当使用new调用时，构造函数内用到的this对象会指向哪？
新创建的对象实例

## 22.5 当没有使用new操作符调用构造函数时，会有何问题？
由于该this对象是运行时绑定，this会映射到全局对象上，导致错误对象属性的意外增加

## 22.6 如何创建作用域安全的构造函数？
在进行任何更改之前，首先确认this对象是正确类型的实例，如果不是，那么会创建新的实例并返回，避免了在全局对象上意外设置属性

## 22.7 作用域安全的构造函数存在什么潜在问题？
实现了作用域安全后，就相当于锁定了调用构造函数的环境，如果使用构造函数窃取模式继承且不使用原型链继承，这个继承很可能被破坏；

## 22.8 惰性载入的技巧用来干啥?
让代码运行得更快，比如存在大量if语句的代码块，即使只有一个if语句，也比没有if语句的慢；

## 22.9 实现惰性载入的技巧有？
第一种是在函数在被调用时再处理函数，在第一次调用过程中，该函数会被覆盖为另一个按合适方式执行的函数；第二种为在声明函数时就指定适当的函数，基于自执行匿名函数；

## 22.10 绑定函数一般在什么场景使用？
回调函数，事件处理程序以及setTimeout()和setInterval()，以便将函数作为变量传递时保留代码执行的环境；function bind(fn, context) { return function () { return fn.apply(context, arguments);};}

## 22.11 为何只有在必要时使用函数绑定？
因为被绑定的函数与普通函数相比，会有更多的开销，比如需要更多的内存，也因为多重调用会慢一些；

## 22.12 函数柯里化的作用是？
用于创建已经设置好了的一个或多个参数的函数；

## 22.13 函数柯里化和函数绑定的异同？
都使用一个闭包返回一个函数，而柯里化中函数被调用时，返回函数还需要设置一些传入的参数；

## 22.14 为何js共享的本质让开发者头疼？
任何任何对象都可以被同一运行环境的代码改变，开发人员很可能意外的修改别人的代码，甚至用不兼容的功能重写原生对象

## 22.15 不可扩展对象、密封对象和冻结对象的区别？
调用了Object.preventExtensions()方法后，就不可以对该对象添加新的属性和方法了；
而调用了Object.seal()方法后，不仅不可扩展，而且不能删除该对象原有的属性和方法；
最严格的防篡改级别是冻结对象，调用了Object.freeze()方法后，不仅不能扩展和删除，甚至修改该对象的已有属性和方法都可以，只能去读。

## 22.16 关于定时器需要记住最重要的事情是？
指定的时间间隔表示何时将定时器的代码添加到队列，而不是何时实际执行代码

## 22.17 为何浏览器要限制JS能控制的内存大小和处理器时间？
防止恶意的web程序吧计算机或者手机搞挂了

## 22.18 造成脚本长时间运行得原因有？
一是过长的或过深嵌套的函数调用；二是进行大量处理的循环；

## 22.19 函数节流背后的基本思想是？
某些代码不可以在没有简断的情况下连续重复执行：
function throttle(method, context) {
       clearTimeout(method.tId);
      method.tId = setTimeout( fuction() {
          method.call(context);
      }, 100);
}  如果没有纯context，则默认子全局环境下执行。

## 22.20 为何当代码中存在多个部分在特定时刻相互交互时，自定义事件非常有用？
使用自定义对象有助于解耦相关对象，保持功能隔绝；

## 23.1什么是离线web应用？
设备在不能上网的情况下仍然可以运行的应用

## 23.2 开发离线web应用的三部曲是？
