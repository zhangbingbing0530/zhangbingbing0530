# 四至六章
## 4.1 如何理解js变量松散类型本质？
这决定了js只在特定的时间用于保存特定值得名字而已，变量的值及其数据类型可以在脚本的生命周期内改变！

## 4.2引用类型与基本类型有什么区别？
基本类型是按值访问的，可以操作保存在变量中的实际值；引用类型的值是保存在内存中的对象，在操作对象时，实际上是在操作对象的引用，因为js不允许直接访问内存；引用类型可以为其添加属性，而基本数据类型则不可，尽管不报错；在复制变量时，基本类型是独立的两个变量，而引用类型中两个变量实际上引用的都是同一个对象，相互影响。

## 4.3 如何理解js中所有函数的参数都是按值传递的？
在向参数传递基本数据类型的值时，被传递的值会被复制给一个局部变量，而在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化回反应在函数的外部；在参数为对象时，如果函数内部重写对象，此时的变量引用的只是局部对象，在函数执行完立即销毁，因此不会影响传进来的 外部对象。

## 4.4如何检测引用类型的具体类型？使用instanceof

## 4.5如何理解函数的执行环境？
当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。

## 4.6作用域链的作用是？
保证对执行环境有权访问的所有变量和函数的有序访问。

## 4.7作用域的头尾是？
前端始终是当前执行代码所在环境的变量对象，后端始终是全局执行环境的变量对象！

## 4.8延长作用域链的方法有？
使用try-catch语句的catch块或者with语句

## 4.9如何理解js的块级作用域？
在ES6引入let关键字之前，不存在块级作用域，所以if或者for等语句执行完后，其内部声明的变量依然会存在于外部变量之中。

## 4.10为何初始化变量之前，最好先声明？
一是在严格模式下，初始化未经声明的变量会导致错误；二是变量会自动被添加到全局环境，容易导致意外。

## 4.11如何理解js的垃圾收集机制？
使用标记清除或引用计数的收集策略，周期性的找出那些不再使用的变量，然后释放其占用的内存。

## 4.12如何避免采用引用计数 垃圾收集策略时出现的循环引用问题？
在不使用时，手工断开原生JS对象与DOM元素之间的连接，如将变量设置为null。

## 4.13为何分配给web浏览器的内存比桌面程序的少？
主要出于安全考虑，防止运行JS网页耗尽全部系统内存而导致系统崩溃。

## 4.14优化内存的最好方式是？
为执行中的代码只保存必要的数据，一旦不用，最好设置为null来释放其引用，让值脱离环境，以便垃圾收集器下次运行时将其回收。

## 4.15基本类型和引用类型在内存中的位置有何不同？
前者保存在栈内存中，后者保存在堆内存中。

## 5.1js中创建对象实例的方法有？
一是使用new操作符后跟Object构造函数；二是使用对象字面量表示法。

## 5.2如何选择访问js对象方法？
除了必须使用变量来访问属性时采用方括号表示法，其他均建议使用点表示法。

## 5.3js中数组类型与其他语言最大的区别是？
每一项可以保存任何类型的数据，并且数组大小是可以通过设置length属性进行动态调整的。

## 5.4创建数组的方式有？
使用Array构造函数法和数组字面量表示法

## 5.5给数组构造函数传递一个值时处理规则是？
如果传递的值时数值，则按照该数值创建给定项数的数组；如果是其他类型的，则会创建只有那一个值得数组。

## 5.6检测数组需要注意什么？
当存在两个以上不同全局执行环境时，instanceof会难以区分不同的数组构造函数，所以在支持Array.isArray()方法的浏览器中使用该方法。

## 5.7js的数组是怎么实现栈和队列的数据结构的？
使用push和pop方法模拟栈，使用shift和push，或unshift和pop模拟双向队列

## 5.8数组的方法有？
isArray, toLocaleString, toString, valueOf, 
push, pop, shift, unshift,
reverse, sort, 
concat, splice,
indexOf, lastIndexOf,
every, filter, forEach, map, some,
reduce, reduceRight,

## 5.9js中定义函数的方法有？
一是使用函数声明语法；二是使用函数表达式；三是使用Function构造函数（不推荐，解析了两次代码而影响性能）。

## 5.10js中函数为何没有指针？
因为每个函数实际都是Function类型对象的实例，函数名只是一个指向函数对象的指针，不会与某个函数绑定，如果申明了两个同名函数，后面的函数会覆盖前面的函数。

## 5.11函数声明和函数表达式的区别？
js引擎会把函数声明提升到顶部，而表达式得到解析器执行到其所在的代码行才会被解释执行。

## 5.12函数名本身是变量有何好处？
使得函数可以作为值来使用，传递参数或者作为函数内部的返回值等。

## 5.13如何理解函数内的arguments对象的callee属性？
指向拥有该arguments对象的函数本身，一般在函数递归时用来消除函数执行与函数名的耦合。

## 5.14函数内部的属性和方法有？
argument和this对象，length和prototype变量，apply，call和bind
toLocaleString, toString, valueOf

## 5.15为何用apply和call？他们的区别？
确保对象不与方法耦合的前提下，去扩充函数执行的作用域；接收参数的方式不同。

## 5.16Boolean, Number和String 特殊引用类型的作用是？特殊在哪？
便于操作基本类型的值；特殊在对象的生存期，使用new操作符创建的引用类型实例，会在执行流离开当前作用域前一直保存在内存中，而特殊类型只存在代码执行的瞬间，并且不能再运行时为其添加属性和方法。

## 5.17使用new调用基本包装类型的构造函数，与调用同名转型函数的区别？
前者返回 的类型为对象，而后者还是基本类型。

## 5.18String类型提供了那些方法和属性辅助js对字符串的解析和操作？
length,继承于对象的toLocaleString, toString, valueOf
charAt, charCodeAt
concat, slice, substr, subtring,
indexOf,lastIndexOf,
trim,
toLowerCase, toLocaleLowerCase, toUpperCase, toLocaleUpperCase,
match, search, replace,localeCompare,
fromCharCode

## 5.19Global对象的方法和属性有？
isNaN, isFinite, parseInt, parseFloat,
encodeURI, encodeURIComponent,
decodeURI, decodeURIComponent,
eval；
undefied, NaN, Infinity,Object, Array, Fuction, Boolean, String, Number

## 5.20为何Math对象提供的计算功能比在JS中直接编写的要快得多啊？
因为其属性和方法都是静态的，js引擎做了优化，少了解析代码的环节。

## 6.1js中的属性有？
数据属性和访问器属性

## 6.2如何修改数据属性的默认值？如何获取？
使用Object.defineProperty()方法修改；
使用Object.getOwnPropertyDescriptor()方法获取；

## 6.3对象如何定义多个属性？
使用Object.defineProperties()方法

## 6.4使用Object构造函数或对象字面量创建对象的共同缺点是？
产生大量重复代码；

## 6.5工厂模式解决了什么问题，还存在什么问题？
解决了创建相似对象的问题，没有解决对象识别的问题；

## 6.6构造函数解决了什么问题，还存在什么问题？与普通函数有何区别？
构造函数可通过其constructor属性来标识它的实例为特定的对象类型，即解决了创建相似对象问题，又解决了对象识别问题，但是每个方法都在实例重新创建了一遍，会导致不同的作用域链和标识符解析，且不同实例的同名函数不相等；
形式上是首字母大小写不同，本质上是调用方式不同，如果构造函数作为普通函数调用，属性和方法都会被添加到全局对象；

## 6.7函数中prototype属性的作用是？
包含可以由特定类型的所有实例共享的属性和方法，其本身也是一个对象，其constructor属性指向包含该原型的构造函数。

## 6.8对象实例与原型中值的规则？
实例可以访问原型中的值，却不能修改，且若实例添加了一个与原型同名的属性，将会屏蔽原型中的属性，阻止实例访问，只有通过delete操作符才能恢复去指向原型的连接。

## 6.9如何确定属性是实例属性还是原型属性？
同时使用hasOwnProperty()方法和in操作符；

## 6.10使用对象字面量重写原型对象有何问题？
其constructor属性指向Object了，需要特意将其显示的设置回特定的值，但会修改其枚举属性，所以最好使用Object.defineProperty()去单独设置；切断了构造函数与最初原型之间的联系，回导致错误。

## 6.11为何不推荐在原型对象中去定义新方法和属性？
可能导致命名冲突，还有就是可能意外重写原生方法。

## 6.12原型对象还存在的问题？
所有的属性都被所有的实例共享。

## 6.13怎么实现组合继承？
使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。

## 6.14寄生式继承为何会降低效率？
因为不能做到函数复用。。。

## 6.15组合继承存在的最大问题是？
总是调用两次超类函数。。。

## 6.16如何实现寄生组合式继承？
通过构造函数来继承属性，通过原型链和混成形式来继承方法。